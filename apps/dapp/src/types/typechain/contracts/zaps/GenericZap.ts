/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace GenericZap {
  export type ZapLiquidityRequestStruct = {
    firstSwapMinAmountOut: PromiseOrValue<BigNumberish>;
    useAltFunction: PromiseOrValue<boolean>;
    poolSwapMinAmountOut: PromiseOrValue<BigNumberish>;
    isOneSidedLiquidityAddition: PromiseOrValue<boolean>;
    otherToken: PromiseOrValue<string>;
    shouldTransferResidual: PromiseOrValue<boolean>;
    minLiquidityOut: PromiseOrValue<BigNumberish>;
    uniAmountAMin: PromiseOrValue<BigNumberish>;
    uniAmountBMin: PromiseOrValue<BigNumberish>;
    poolSwapData: PromiseOrValue<BytesLike>;
  };

  export type ZapLiquidityRequestStructOutput = [
    BigNumber,
    boolean,
    BigNumber,
    boolean,
    string,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    firstSwapMinAmountOut: BigNumber;
    useAltFunction: boolean;
    poolSwapMinAmountOut: BigNumber;
    isOneSidedLiquidityAddition: boolean;
    otherToken: string;
    shouldTransferResidual: boolean;
    minLiquidityOut: BigNumber;
    uniAmountAMin: BigNumber;
    uniAmountBMin: BigNumber;
    poolSwapData: string;
  };
}

export declare namespace IBalancerVault {
  export type JoinPoolRequestStruct = {
    assets: PromiseOrValue<string>[];
    maxAmountsIn: PromiseOrValue<BigNumberish>[];
    userData: PromiseOrValue<BytesLike>;
    fromInternalBalance: PromiseOrValue<boolean>;
  };

  export type JoinPoolRequestStructOutput = [
    string[],
    BigNumber[],
    string,
    boolean
  ] & {
    assets: string[];
    maxAmountsIn: BigNumber[];
    userData: string;
    fromInternalBalance: boolean;
  };
}

export interface GenericZapInterface extends utils.Interface {
  functions: {
    "addLiquidityGetMinAmounts(uint256,uint256,address)": FunctionFragment;
    "approvedTargets(address,address)": FunctionFragment;
    "getAmountToSwap(address,address,uint256)": FunctionFragment;
    "getSwapInAmount(uint256,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "paused()": FunctionFragment;
    "recoverToken(address,address,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setApprovedTargets(address[],address[],bool[])": FunctionFragment;
    "toggleContractActive()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "uniswapV2Router()": FunctionFragment;
    "zapIn(address,uint256,address,uint256,address,bytes)": FunctionFragment;
    "zapInFor(address,uint256,address,uint256,address,address,bytes)": FunctionFragment;
    "zapLiquidityBalancerPool(address,uint256,bytes32,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes),(address[],uint256[],bytes,bool))": FunctionFragment;
    "zapLiquidityBalancerPoolFor(address,uint256,bytes32,address,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes),(address[],uint256[],bytes,bool))": FunctionFragment;
    "zapLiquidityCurvePool(address,uint256,address,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes))": FunctionFragment;
    "zapLiquidityCurvePoolFor(address,uint256,address,address,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes))": FunctionFragment;
    "zapLiquidityUniV2(address,uint256,address,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes))": FunctionFragment;
    "zapLiquidityUniV2For(address,uint256,address,address,address,bytes,(uint248,bool,uint248,bool,address,bool,uint256,uint256,uint256,bytes))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addLiquidityGetMinAmounts"
      | "approvedTargets"
      | "getAmountToSwap"
      | "getSwapInAmount"
      | "owner"
      | "paused"
      | "recoverToken"
      | "renounceOwnership"
      | "setApprovedTargets"
      | "toggleContractActive"
      | "transferOwnership"
      | "uniswapV2Router"
      | "zapIn"
      | "zapInFor"
      | "zapLiquidityBalancerPool"
      | "zapLiquidityBalancerPoolFor"
      | "zapLiquidityCurvePool"
      | "zapLiquidityCurvePoolFor"
      | "zapLiquidityUniV2"
      | "zapLiquidityUniV2For"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addLiquidityGetMinAmounts",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approvedTargets",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAmountToSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapInAmount",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recoverToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovedTargets",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<boolean>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "toggleContractActive",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV2Router",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "zapIn",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapInFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityBalancerPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct,
      IBalancerVault.JoinPoolRequestStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityBalancerPoolFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct,
      IBalancerVault.JoinPoolRequestStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityCurvePool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityCurvePoolFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityUniV2",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapLiquidityUniV2For",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      GenericZap.ZapLiquidityRequestStruct
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidityGetMinAmounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approvedTargets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAmountToSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapInAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "recoverToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovedTargets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toggleContractActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV2Router",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "zapIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "zapInFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityBalancerPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityBalancerPoolFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityCurvePool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityCurvePoolFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityUniV2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapLiquidityUniV2For",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
    "SetContractState(bool)": EventFragment;
    "TokenRecovered(address,address,uint256)": EventFragment;
    "ZappedIn(address,address,uint256,address,uint256)": EventFragment;
    "ZappedLPCurve(address,address,uint256,uint256[])": EventFragment;
    "ZappedLPUniV2(address,address,address,uint256,uint256)": EventFragment;
    "ZappedLiquidityBalancerPool(address,address,uint256,uint256[])": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetContractState"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenRecovered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZappedIn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZappedLPCurve"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZappedLPUniV2"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ZappedLiquidityBalancerPool"
  ): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SetContractStateEventObject {
  paused: boolean;
}
export type SetContractStateEvent = TypedEvent<
  [boolean],
  SetContractStateEventObject
>;

export type SetContractStateEventFilter =
  TypedEventFilter<SetContractStateEvent>;

export interface TokenRecoveredEventObject {
  token: string;
  to: string;
  amount: BigNumber;
}
export type TokenRecoveredEvent = TypedEvent<
  [string, string, BigNumber],
  TokenRecoveredEventObject
>;

export type TokenRecoveredEventFilter = TypedEventFilter<TokenRecoveredEvent>;

export interface ZappedInEventObject {
  sender: string;
  fromToken: string;
  fromAmount: BigNumber;
  toToken: string;
  amountOut: BigNumber;
}
export type ZappedInEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber],
  ZappedInEventObject
>;

export type ZappedInEventFilter = TypedEventFilter<ZappedInEvent>;

export interface ZappedLPCurveEventObject {
  recipient: string;
  fromToken: string;
  liquidity: BigNumber;
  amounts: BigNumber[];
}
export type ZappedLPCurveEvent = TypedEvent<
  [string, string, BigNumber, BigNumber[]],
  ZappedLPCurveEventObject
>;

export type ZappedLPCurveEventFilter = TypedEventFilter<ZappedLPCurveEvent>;

export interface ZappedLPUniV2EventObject {
  recipient: string;
  token0: string;
  token1: string;
  amountA: BigNumber;
  amountB: BigNumber;
}
export type ZappedLPUniV2Event = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  ZappedLPUniV2EventObject
>;

export type ZappedLPUniV2EventFilter = TypedEventFilter<ZappedLPUniV2Event>;

export interface ZappedLiquidityBalancerPoolEventObject {
  recipient: string;
  fromToken: string;
  fromAmount: BigNumber;
  maxAmountsIn: BigNumber[];
}
export type ZappedLiquidityBalancerPoolEvent = TypedEvent<
  [string, string, BigNumber, BigNumber[]],
  ZappedLiquidityBalancerPoolEventObject
>;

export type ZappedLiquidityBalancerPoolEventFilter =
  TypedEventFilter<ZappedLiquidityBalancerPoolEvent>;

export interface GenericZap extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GenericZapInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addLiquidityGetMinAmounts(
      amountADesired: PromiseOrValue<BigNumberish>,
      amountBDesired: PromiseOrValue<BigNumberish>,
      pair: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountA: BigNumber; amountB: BigNumber }
    >;

    approvedTargets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getAmountToSwap(
      _token: PromiseOrValue<string>,
      _pair: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getSwapInAmount(
      _reserveIn: PromiseOrValue<BigNumberish>,
      _userIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    recoverToken(
      _token: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovedTargets(
      _tokens: PromiseOrValue<string>[],
      _targets: PromiseOrValue<string>[],
      _isApproved: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    toggleContractActive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    uniswapV2Router(overrides?: CallOverrides): Promise<[string]>;

    zapIn(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _toToken: PromiseOrValue<string>,
      _amountOutMin: PromiseOrValue<BigNumberish>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapInFor(
      fromToken: PromiseOrValue<string>,
      fromAmount: PromiseOrValue<BigNumberish>,
      toToken: PromiseOrValue<string>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      swapTarget: PromiseOrValue<string>,
      swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityBalancerPool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityBalancerPoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityCurvePool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityCurvePoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityUniV2(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    zapLiquidityUniV2For(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _for: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  addLiquidityGetMinAmounts(
    amountADesired: PromiseOrValue<BigNumberish>,
    amountBDesired: PromiseOrValue<BigNumberish>,
    pair: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { amountA: BigNumber; amountB: BigNumber }
  >;

  approvedTargets(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getAmountToSwap(
    _token: PromiseOrValue<string>,
    _pair: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSwapInAmount(
    _reserveIn: PromiseOrValue<BigNumberish>,
    _userIn: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  recoverToken(
    _token: PromiseOrValue<string>,
    _to: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovedTargets(
    _tokens: PromiseOrValue<string>[],
    _targets: PromiseOrValue<string>[],
    _isApproved: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  toggleContractActive(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  uniswapV2Router(overrides?: CallOverrides): Promise<string>;

  zapIn(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _toToken: PromiseOrValue<string>,
    _amountOutMin: PromiseOrValue<BigNumberish>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapInFor(
    fromToken: PromiseOrValue<string>,
    fromAmount: PromiseOrValue<BigNumberish>,
    toToken: PromiseOrValue<string>,
    amountOutMin: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    swapTarget: PromiseOrValue<string>,
    swapData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityBalancerPool(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _poolId: PromiseOrValue<BytesLike>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    _request: IBalancerVault.JoinPoolRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityBalancerPoolFor(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _poolId: PromiseOrValue<BytesLike>,
    _recipient: PromiseOrValue<string>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    _request: IBalancerVault.JoinPoolRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityCurvePool(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _pool: PromiseOrValue<string>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityCurvePoolFor(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _pool: PromiseOrValue<string>,
    _recipient: PromiseOrValue<string>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityUniV2(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _pair: PromiseOrValue<string>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  zapLiquidityUniV2For(
    _fromToken: PromiseOrValue<string>,
    _fromAmount: PromiseOrValue<BigNumberish>,
    _pair: PromiseOrValue<string>,
    _for: PromiseOrValue<string>,
    _swapTarget: PromiseOrValue<string>,
    _swapData: PromiseOrValue<BytesLike>,
    _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addLiquidityGetMinAmounts(
      amountADesired: PromiseOrValue<BigNumberish>,
      amountBDesired: PromiseOrValue<BigNumberish>,
      pair: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountA: BigNumber; amountB: BigNumber }
    >;

    approvedTargets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getAmountToSwap(
      _token: PromiseOrValue<string>,
      _pair: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSwapInAmount(
      _reserveIn: PromiseOrValue<BigNumberish>,
      _userIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    recoverToken(
      _token: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setApprovedTargets(
      _tokens: PromiseOrValue<string>[],
      _targets: PromiseOrValue<string>[],
      _isApproved: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    toggleContractActive(overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    uniswapV2Router(overrides?: CallOverrides): Promise<string>;

    zapIn(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _toToken: PromiseOrValue<string>,
      _amountOutMin: PromiseOrValue<BigNumberish>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zapInFor(
      fromToken: PromiseOrValue<string>,
      fromAmount: PromiseOrValue<BigNumberish>,
      toToken: PromiseOrValue<string>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      swapTarget: PromiseOrValue<string>,
      swapData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zapLiquidityBalancerPool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    zapLiquidityBalancerPoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    zapLiquidityCurvePool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    zapLiquidityCurvePoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    zapLiquidityUniV2(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    zapLiquidityUniV2For(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _for: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "SetContractState(bool)"(paused?: null): SetContractStateEventFilter;
    SetContractState(paused?: null): SetContractStateEventFilter;

    "TokenRecovered(address,address,uint256)"(
      token?: null,
      to?: null,
      amount?: null
    ): TokenRecoveredEventFilter;
    TokenRecovered(
      token?: null,
      to?: null,
      amount?: null
    ): TokenRecoveredEventFilter;

    "ZappedIn(address,address,uint256,address,uint256)"(
      sender?: PromiseOrValue<string> | null,
      fromToken?: null,
      fromAmount?: null,
      toToken?: null,
      amountOut?: null
    ): ZappedInEventFilter;
    ZappedIn(
      sender?: PromiseOrValue<string> | null,
      fromToken?: null,
      fromAmount?: null,
      toToken?: null,
      amountOut?: null
    ): ZappedInEventFilter;

    "ZappedLPCurve(address,address,uint256,uint256[])"(
      recipient?: PromiseOrValue<string> | null,
      fromToken?: null,
      liquidity?: null,
      amounts?: null
    ): ZappedLPCurveEventFilter;
    ZappedLPCurve(
      recipient?: PromiseOrValue<string> | null,
      fromToken?: null,
      liquidity?: null,
      amounts?: null
    ): ZappedLPCurveEventFilter;

    "ZappedLPUniV2(address,address,address,uint256,uint256)"(
      recipient?: PromiseOrValue<string> | null,
      token0?: null,
      token1?: null,
      amountA?: null,
      amountB?: null
    ): ZappedLPUniV2EventFilter;
    ZappedLPUniV2(
      recipient?: PromiseOrValue<string> | null,
      token0?: null,
      token1?: null,
      amountA?: null,
      amountB?: null
    ): ZappedLPUniV2EventFilter;

    "ZappedLiquidityBalancerPool(address,address,uint256,uint256[])"(
      recipient?: PromiseOrValue<string> | null,
      fromToken?: null,
      fromAmount?: null,
      maxAmountsIn?: null
    ): ZappedLiquidityBalancerPoolEventFilter;
    ZappedLiquidityBalancerPool(
      recipient?: PromiseOrValue<string> | null,
      fromToken?: null,
      fromAmount?: null,
      maxAmountsIn?: null
    ): ZappedLiquidityBalancerPoolEventFilter;
  };

  estimateGas: {
    addLiquidityGetMinAmounts(
      amountADesired: PromiseOrValue<BigNumberish>,
      amountBDesired: PromiseOrValue<BigNumberish>,
      pair: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approvedTargets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAmountToSwap(
      _token: PromiseOrValue<string>,
      _pair: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSwapInAmount(
      _reserveIn: PromiseOrValue<BigNumberish>,
      _userIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    recoverToken(
      _token: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovedTargets(
      _tokens: PromiseOrValue<string>[],
      _targets: PromiseOrValue<string>[],
      _isApproved: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    toggleContractActive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    uniswapV2Router(overrides?: CallOverrides): Promise<BigNumber>;

    zapIn(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _toToken: PromiseOrValue<string>,
      _amountOutMin: PromiseOrValue<BigNumberish>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapInFor(
      fromToken: PromiseOrValue<string>,
      fromAmount: PromiseOrValue<BigNumberish>,
      toToken: PromiseOrValue<string>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      swapTarget: PromiseOrValue<string>,
      swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityBalancerPool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityBalancerPoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityCurvePool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityCurvePoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityUniV2(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    zapLiquidityUniV2For(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _for: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidityGetMinAmounts(
      amountADesired: PromiseOrValue<BigNumberish>,
      amountBDesired: PromiseOrValue<BigNumberish>,
      pair: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approvedTargets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAmountToSwap(
      _token: PromiseOrValue<string>,
      _pair: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSwapInAmount(
      _reserveIn: PromiseOrValue<BigNumberish>,
      _userIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverToken(
      _token: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovedTargets(
      _tokens: PromiseOrValue<string>[],
      _targets: PromiseOrValue<string>[],
      _isApproved: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    toggleContractActive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    uniswapV2Router(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    zapIn(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _toToken: PromiseOrValue<string>,
      _amountOutMin: PromiseOrValue<BigNumberish>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapInFor(
      fromToken: PromiseOrValue<string>,
      fromAmount: PromiseOrValue<BigNumberish>,
      toToken: PromiseOrValue<string>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      swapTarget: PromiseOrValue<string>,
      swapData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityBalancerPool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityBalancerPoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _poolId: PromiseOrValue<BytesLike>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      _request: IBalancerVault.JoinPoolRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityCurvePool(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityCurvePoolFor(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pool: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityUniV2(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    zapLiquidityUniV2For(
      _fromToken: PromiseOrValue<string>,
      _fromAmount: PromiseOrValue<BigNumberish>,
      _pair: PromiseOrValue<string>,
      _for: PromiseOrValue<string>,
      _swapTarget: PromiseOrValue<string>,
      _swapData: PromiseOrValue<BytesLike>,
      _zapLiqRequest: GenericZap.ZapLiquidityRequestStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
